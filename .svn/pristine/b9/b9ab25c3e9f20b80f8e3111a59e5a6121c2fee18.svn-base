package com.unlogical.colored.particle;

import java.util.Random;

import org.newdawn.slick.Color;

import com.unlogical.colored.util.ColorTransformer;

public enum ColorDistributionMode implements IColorDistributionMode
{
	RGB_LINEAR()
	{
		@Override
		public Color getColor(Color startColor, Color endColor, Random rng)
		{
			float rngFloat = rng.nextFloat();

			colorBuffer.r = Math.min(startColor.r, endColor.r) + rngFloat * (Math.abs(endColor.r - startColor.r));
			colorBuffer.g = Math.min(startColor.g, endColor.g) + rngFloat * (Math.abs(endColor.g - startColor.g));
			colorBuffer.b = Math.min(startColor.b, endColor.b) + rngFloat * (Math.abs(endColor.b - startColor.b));

			return colorBuffer;
		}
	},

	RGB_AREA()
	{
		@Override
		public Color getColor(Color startColor, Color endColor, Random rng)
		{
			colorBuffer.r = Math.min(startColor.r, endColor.r) + rng.nextFloat() * (Math.abs(endColor.r - startColor.r));
			colorBuffer.g = Math.min(startColor.g, endColor.g) + rng.nextFloat() * (Math.abs(endColor.g - startColor.g));
			colorBuffer.b = Math.min(startColor.b, endColor.b) + rng.nextFloat() * (Math.abs(endColor.b - startColor.b));

			return colorBuffer;
		}
	},
	
	HSV_LINEAR()
	{
		@Override
		public Color getColor(Color startColor, Color endColor, Random rng)
		{
			float[] startHSV = ColorTransformer.toHSVColor(startColor, ColorTransformer.floatBuffer1);
			float[] endHSV = ColorTransformer.toHSVColor(endColor, ColorTransformer.floatBuffer2);
			float[] result = ColorTransformer.floatBuffer3;
			float rngFloat = rng.nextFloat();

			result[0] = Math.min(startHSV[0], endHSV[0]) + rngFloat * Math.abs(endHSV[0] - startHSV[0]);
			result[1] = Math.min(startHSV[1], endHSV[1]) + rngFloat * Math.abs(endHSV[1] - startHSV[1]);
			result[2] = Math.min(startHSV[2], endHSV[2]) + rngFloat * Math.abs(endHSV[2] - startHSV[2]);

			return ColorTransformer.toRGBColor(result, ColorTransformer.colorBuffer1);
		}
	},
	
	HSV_AREA()
	{
		@Override
		public Color getColor(Color startColor, Color endColor, Random rng)
		{
			float[] startHSV = ColorTransformer.toHSVColor(startColor, ColorTransformer.floatBuffer1);
			float[] endHSV = ColorTransformer.toHSVColor(endColor, ColorTransformer.floatBuffer2);
			float[] result = ColorTransformer.floatBuffer3;

			result[0] = Math.min(startHSV[0], endHSV[0]) + rng.nextFloat() * Math.abs(endHSV[0] - startHSV[0]);
			result[1] = Math.min(startHSV[1], endHSV[1]) + rng.nextFloat() * Math.abs(endHSV[1] - startHSV[1]);
			result[2] = Math.min(startHSV[2], endHSV[2]) + rng.nextFloat() * Math.abs(endHSV[2] - startHSV[2]);

			return ColorTransformer.toRGBColor(result, ColorTransformer.colorBuffer1);
		}
	},

	;

	private static Color colorBuffer = new Color(1.0f, 1.0f, 1.0f);

	public ColorDistributionMode next()
	{
		return values()[this.ordinal() + 1 >= values().length ? 0 : this.ordinal() + 1];
	}
}
