package com.unlogical.colored.gui.menu;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.Rectangle;
import com.unlogical.colored.GameLauncher;
import com.unlogical.colored.configuration.Resolutions;
import com.unlogical.colored.input.InputAction;
import com.unlogical.colored.input.InputHandler;
import com.unlogical.colored.resources.font.Fonts;
import com.unlogical.colored.sound.Sounds;
import com.unlogical.colored.util.ColorHelper;
import com.unlogical.colored.util.Renderer;
import com.unlogical.colored.util.ShaderHandler;

public abstract class Menu
{
	public static final float UNSELECTED_ALPHA = 0.8f;
	public static final float SELECTED_ALPHA = 1.0f;

	public static final Color UNSELECTED_COLOR = new Color(0.8f, 0.8f, 0.8f, UNSELECTED_ALPHA);
	public static final Color SELECTION_COLOR = new Color(1.0f, 1.0f, 1.0f, SELECTED_ALPHA);

	private Rectangle[] menuOptions;
	protected final String[] options;

	private boolean active;
	private boolean selecting = true;
	protected boolean ignoreButtons;

	private final int CLICK_COOLDOWN = 500;

	private int selectedOption;
	private int clickCooldown;
	private int height;

	protected float width;

	protected Color unselectedColor = new Color(UNSELECTED_COLOR);
	protected Color selectedColor = new Color(SELECTION_COLOR);

	private float xOffset;
	private float yOffset;
	private float offset;

	public Menu(final String[] options, float xOffset, float yOffset, float width, float offset, boolean centered)
	{
		this.options = options;
		this.xOffset = xOffset;
		this.yOffset = yOffset;
		this.offset = offset;
		this.menuOptions = new Rectangle[options.length];

		String longestString = "";

		for (String option : options)
		{
			if (option.length() > longestString.length())
			{
				longestString = option;
			}
		}

		this.width = width;
		boolean useCalculatedWidth = this.width == 0.0f;

		if (useCalculatedWidth)
		{
			this.width = Renderer.getWidth(longestString, Fonts.getDefaultFont());
		}

		for (int i = 0; i < this.options.length; i++)
		{
			if (centered)
			{
				menuOptions[i] = new Rectangle(GameLauncher.getWidth() / 2 - Renderer.getWidth(options[i], Fonts.getDefaultFont()) / 2, yOffset + i * offset - Resolutions.MENU_RECTANGLE_OFFSET, useCalculatedWidth ? Renderer.getWidth(options[i], Fonts.getDefaultFont()) : width, Resolutions.MENU_RECTANGLE_HEIGHT);
			}
			else
			{
				menuOptions[i] = new Rectangle(xOffset, yOffset + i * offset - Resolutions.MENU_RECTANGLE_OFFSET, useCalculatedWidth ? Renderer.getWidth(options[i], Fonts.getDefaultFont()) : width, Resolutions.MENU_RECTANGLE_HEIGHT);
			}
		}

		this.height = (int) (menuOptions[this.options.length - 1].getY() + menuOptions[this.options.length -1].height - menuOptions[0].getY());
	}

	public void update(int delta)
	{
		clickCooldown -= delta;

		for (int i = 0; i < options.length; i++)
		{
			if (menuOptions[i].contains(InputHandler.getCurrentInputX(), InputHandler.getCurrentInputY()) && !ignoreButtons)
			{
				selectedOption = i;
				selecting = true;
			}
		}

		if (!ignoreButtons)
		{
			if (InputHandler.isKeyPressed(InputAction.MOVE_DOWN))
			{
				selectedOption++;
				if (selectedOption == options.length)
				{
					selectedOption = 0;
				}

				selecting = true;
			}

			if (InputHandler.isKeyPressed(InputAction.MOVE_UP))
			{
				selectedOption--;
				if (selectedOption < 0)
				{
					selectedOption = options.length - 1;
				}

				selecting = true;
			}
		}

		if (isAvailable(selectedOption))
		{
			if (InputHandler.isKeyPressed(InputAction.BACK) && !(this instanceof MainMenu))
			{
				onSelect(menuOptions.length - 1);
				Sounds.play("click");
			}
	
			if (((Gdx.input.isKeyPressed(Input.Keys.ENTER) || InputHandler.isKeyPressed(InputAction.JUMP) || (menuOptions[selectedOption].contains(InputHandler.getCurrentInputX(), InputHandler.getCurrentInputY()) && Gdx.input.isButtonPressed(Input.Buttons.LEFT) && Gdx.input.justTouched()) && clickCooldown <= 0)) && selecting)
			{
				onSelect(selectedOption);
				Sounds.play("click");
				clickCooldown = CLICK_COOLDOWN;
			}
		}

		customUpdate(delta);
	}

	public void render(Batch batch)
	{
		if (active)
		{
			ShaderHandler.disableLighting();
			
			for (int i = 0; i < options.length; i++)
			{
				Renderer.setFont(Fonts.getDefaultFont());

				Color baseColor = isAvailable(i) ? Color.WHITE : ColorHelper.applyAlphaAndCopy(Color.GRAY, 0.5f);
								
				batch.setColor(ColorHelper.multiplyAndCopy(baseColor, selectedOption == i ? selectedColor : unselectedColor));
				Renderer.drawString(options[i], batch.getColor(), menuOptions[i].getX(), menuOptions[i].getY() + menuOptions[i].height / 2 - Renderer.getLineHeight() / 2, batch);
				
				customOptionRender(batch, i, menuOptions[i]);
			}

			customRender(batch);
			
			ShaderHandler.enableLighting();
		}
	}
	
	protected boolean isAvailable(int option)
	{
		return true;
	}

	protected void customOptionRender(Batch batch, int option, Rectangle box)
	{

	}

	public int getHeight()
	{
		return height;
	}

	public abstract void onSelect(int selection);

	public boolean isActive()
	{
		return this.active;
	}

	public void setActive(boolean b)
	{
		this.active = b;
	}

	public float getY()
	{
		return yOffset;
	}

	public float getY(int option)
	{
		return menuOptions[option].getY();
	}

	public void setyOffset(float yOffset)
	{
		this.yOffset = yOffset;
	}

	public float getOffset()
	{
		return offset;
	}

	public void setOffset(float offset)
	{
		this.offset = offset;
	}

	public float getXOffset()
	{
		return xOffset;
	}

	public void customUpdate(int delta)
	{
	}

	public void customRender(Batch batch)
	{
	}

	public String[] getOptions()
	{
		return options;
	}

	public int getSelectedOption()
	{
		return selectedOption;
	}

	public void setSelectedOption(int selectedOption)
	{
		this.selectedOption = selectedOption;
	}

	public float getWidth()
	{
		return width;
	}
}
